[
  {
    "objectID": "04-logic.html",
    "href": "04-logic.html",
    "title": "04-logic.lean",
    "section": "",
    "text": "import Mathlib",
    "crumbs": [
      "04-logic.lean"
    ]
  },
  {
    "objectID": "04-logic.html#true-false-and-not",
    "href": "04-logic.html#true-false-and-not",
    "title": "04-logic.lean",
    "section": "1 True, False and Not",
    "text": "1 True, False and Not\nIn Lean’s dependent type theory, True and False are propositions serving as the terminal and initial objects in the universe of Prop.\nEagle-eyed readers may notice that True and False act similarly to singleton sets and empty sets in set theory.\nThey are constructed as inductive types.\nsection\n\nvariable (p q : Prop)\n\n\n1.1 True (⊤)\nTrue has a single constructor True.intro, which produces the unique proof of True. True is self-evidently true by True.intro.\n#check True.intro\nTrue as the terminal object\nexample : p → True := by\n  intro _\n  exact True.intro\nThe following examples shows that True → p is logically equivalent to p.\nexample (hp : p) : True → p := by\n  intro _\n  exact hp\n[IGNORE] Above is actually the elimination law of True.\nexample (hp : p) : True → p := True.rec hp\n\nexample (htp : True → p) : p := htp True.intro\ntrivial is a tactic that solves goals of type True using True.intro, though it’s power does not stop here.\nexample (htp : True → p) : p := by\n  apply htp\n  trivial\n\n\n1.2 False (⊥)\nFalse has no constructors, meaning that there is no way to construct a proof of False. This means that False is always false.\nFalse.elim is the eliminator of False, serve as the “principle of explosion”, which allows us to derive anything from a falsehood. False.elim is self-evidently true in Lean’s dependent type theory.\n#check False.elim\n#check False.rec -- [IGNORE] `False.elim` is actually defined as `False.rec`\neliminating False\nexample (hf : False) : p := False.elim hf\nexfalso is a tactic that applys False.elim to the current goal, changing it to False.\nexample (hf : False) : p := by\n  exfalso\n  exact hf\ncontradiction is a tactic that proves the current goal by finding a trivial contradiction in the context.\nexample (hf : False) : p := by\n  contradiction\n\n-- [EXR]\nexample (h : 1 + 1 = 3) : RiemannHypothesis := by\n  contradiction\nOn how to actually obtain a proof of False from a trivially false hypothesis via term-style proof [TODO], see here\n[IGNORE] Experienced audiences may question why False.elim lands in Sort* universe instead of Prop. This is because False is a subsingleton. See the manual to understand how the universe of a recursor is determined.\nend",
    "crumbs": [
      "04-logic.lean"
    ]
  },
  {
    "objectID": "04-logic.html#not",
    "href": "04-logic.html#not",
    "title": "04-logic.lean",
    "section": "2 Not (¬)",
    "text": "2 Not (¬)\nIn Lean’s dependent type theory, negation ¬p is realized as p → False\nYou may understand ¬p as “if p then absurd”, indicating that p cannot be true.\nsection\n\nvariable (p q : Prop)\n\n#print Not\nthis has a name absurd in Lean\n#check absurd\nexample (hp : p) (hnp : ¬p) : False := hnp hp\n[EXR] contraposition\nexample : (p → q) → (¬q → ¬p) := by\n  intro hpq hnq hp\n  exact hnq (hpq hp)\ncontrapose! is a tactic that does exactly this. We shall discuss this later.\n[EXR]\nexample : ¬True → False := by\n  intro h\n  exact h True.intro\n[EXR]\nexample : ¬False := by\n  intro h\n  exact h\n[EXR] double negation introduction\nexample : p → ¬¬p := by\n  intro hp hnp\n  exact hnp hp\nDouble negation elimination is not valid in intuitionistic logic. You’ll need proof by contradiction Classical.byContradiction to prove it. The tactic by_contra is created for this purpose. If the goal is p, then by_contra hnp changes the goal to False, and adds the hypothesis hnp : ¬p into the context.\n#check Classical.byContradiction\ndouble negation elimination\nexample : ¬¬p → p := by\n  intro hnnp\n  by_contra hnp\n  exact hnnp hnp\nYou can use the following command to check what axioms are used in the proof\n#print axioms Classical.not_not -- above has a name\nFor logical lunatics:\nIn Lean, Classical.byContradiction is proved by the fact that all propositions are Decidable in classical logic, which is a result of - the axiom of choice Classical.choice - the law of excluded middle Classical.em, which is a result of - the axiom of choice Classical.choice - function extensionality funext, which is a result of - the quotient axiom Quot.sound - propositional extensionality propext\nYou can always trace back like this in Lean, by ctrl-clicking the names. This is a reason why Lean is awesome for learning logic and mathematics.\n[EXR] another side of contraposition\nexample : (¬q → ¬p) → (p → q) := by\n  intro hnqnp hp\n  by_contra hnq\n  exact hnqnp hnq hp\n\nend\n[IGNORE] In fact above is equivalent to double negation elimination. This one use the have tactic, which allows us to state and prove a lemma in the middle of a proof.\nexample (hctp : (p q : Prop) → (¬q → ¬p) → (p → q)) : (p : Prop) → (¬¬p → p) := by\n  intro p hnnp\n  have h : (¬p → ¬True) := by\n    intro hnp _\n    exact hnnp hnp\n  apply hctp True p h\n  trivial",
    "crumbs": [
      "04-logic.lean"
    ]
  },
  {
    "objectID": "04-logic.html#pushing-negations",
    "href": "04-logic.html#pushing-negations",
    "title": "04-logic.lean",
    "section": "3 Pushing negations",
    "text": "3 Pushing negations\nSome negation can be pushed within intuitionistic logic. Some cannot.\n\n3.1 Negation with ∧ and ∨\nsection\n\nvariable (p q r : Prop)\nClassical logic: case analysis\nexample (hpq : p → q) (hnpq : ¬p → q) : q := Or.elim (Classical.em p) hpq hnpq\n#check Classical.byCases -- above has a name\nWe have a corresponding tactic: by_cases\nexample (hpq : p → q) (hnpq : ¬p → q) : q := by\n  by_cases hp : p\n  · exact hpq hp\n  · exact hnpq hp\nProof by cases would help us to obtain an equivalent characterization of Or.\nexample : (p ∨ q) ↔ (¬p → q) := by\n  constructor\n  · rintro (hp | hq)\n    · intro hnp\n      exfalso\n      exact hnp hp\n    · intro _\n      exact hq\n  · intro hnpq  -- the direction of constructing `Or` needs classical logic\n    by_cases h?p : p\n    · left; exact h?p\n    · right; exact hnpq h?p\nNote that this vividly illustrates the difference between classical logic and intuitionistic logic.\nIn intuitionistic logic, Or means slightly stronger than in classical logic: by p ∨ q we mean that we know explicitly which one of p and q is true. We cannot do implications like ¬p → q implying p ∨ q, because we don’t know exactly which one of p and ¬p is true, and the introduction rules of Or are asking us to provide it explicitly. This is a reason why intuitionistic logic is considered to be computable.\nWe also have an equivalent characterization of And. This is also done in classical logic.\nexample : (p ∧ q) ↔ ¬(p → ¬q) := by\n  constructor\n  · intro ⟨hp, hnq⟩ hpnq\n    exact hpnq hp hnq\n  · intro hnpnq -- the direction of constructing `And` needs classical logic\n    contrapose hnpnq\n    rw [Classical.not_not]\n    intro hp hq\n    exact hnpnq ⟨hp, hq⟩\n[EXR] →–∨ distribution\nexample : (r → p ∨ q) ↔ ((r → p) ∨ (r → q)) := by\n  constructor\n  · intro hrpq -- this direction needs classical logic\n    by_cases h?r : r\n    · rcases hrpq h?r with (hp | hq)\n      · left; intro _; exact hp\n      · right; intro _; exact hq\n    · left\n      intro hr\n      exfalso; exact h?r hr\n  · rintro (hrp | hrq)\n    · intro hr\n      left; exact hrp hr\n    · intro hr\n      right; exact hrq hr\n#check imp_or -- above has a name\n[EXR] De Morgan’s laws\nexample : ¬(p ∨ q) ↔ ¬p ∧ ¬q := by\n  constructor\n  · intro hnq\n    constructor\n    · intro hp\n      apply hnq\n      left; exact hp\n    · intro hq\n      apply hnq\n      right\n      exact hq\n  · rintro ⟨hnp, hnq⟩ (hp | hq)\n    · exact hnp hp\n    · exact hnq hq\n#check not_or -- above has a name\n[EXR] De Morgan’s laws\nexample : ¬(p ∧ q) ↔ ¬p ∨ ¬q := by\n  constructor\n  · intro hnpq -- this direction needs classical logic\n    by_cases h?p : p\n    · right\n      intro hq\n      apply hnpq\n      exact ⟨h?p, hq⟩\n    · left\n      exact h?p\n  · rintro (hnp | hnq) ⟨hp, hq⟩\n    · exact hnp hp\n    · exact hnq hq\n#check not_and -- above has a name\nIntroducing push_neg tactic: automatically proves all the above. It works in classical logic where negation normal forms exist.\nby_contra!, contrapose! are push_neg-enhanced version of their non-! counterparts.\nFor more exercises, see Propositions and Proofs - TPiL4\nend\n\n\n3.2 [IGNORE] Decidable\nIt’s high time to introduce Decidable here for the first time.\nMathematicians are often aware of intuitionistic logic. They know classical logic is equipped with Classical.em: p ∨ ¬p for any proposition p. Though rarely do they know the concept of Decidable, which more often appears in the theory of computation.\nFor short, Decidable p means exactly the same as p ∨ ¬p in intuitionistic logic. It means that we know explicitly (or computationally) which one of p and ¬p is true.\nThough formally in Lean, Decidable is defined as a distinct inductive type, it is very similar to Or in that you may, somehow, even use it like a p ∨ ¬p. But there are major differences. They are:\n\n[IGNORE] Decidable lives in Type universe, instead of Prop universe.\nIn Lean’s dependent type theory, things in Prop universe are allowed to be non-constructive. This is because in Prop universe, proofs are proof-irrelevant: Lean forgets the exact proof of a proposition once it is proved. So when we have an Or, we actually have no idea which one of the two sides is true. Lean is designed so, probably because most of the mathematics is non-constructive.\nOn the other hand, things in Type universe are required to be constructive, unless you have used Classical.choice (In such situation, Lean will require you to tag it as noncomputable).\nDecidable is designed to be constructive, because it is used to decide whether a proposition is true or false by computation. So Decidable must live in Type universe: To save whether p or ¬p is true.\nIn short, Prop is non-constructive and proof-irrelevant, while Type is constructive and saves data. This makes Decidable stronger than a pure proof of p ∨ ¬p : Prop.\n[IGNORE] It is tagged as a typeclass.\nThis allows Lean to automatically find a proof of Decidable p so that you don’t have to prove it yourself.\nSo at many places Decidable p is implicitly deduced.\nThe constructors of Decidable has different names: isTrue and isFalse\n\nTo wrap up, we have Decidable because:\n\nTo mean exactly the same as p ∨ ¬p in intuitionistic logic, to make it computable.\nTo allow you to just assume p ∨ ¬p for only some propositions, which is more flexible than a classical logic overkill.\n\nsection\n\nvariable (p q : Prop)\n\n#print Decidable\n#check Decidable.isTrue\n#check Decidable.isFalse\nDecidable enables computational reasoning to see if a proposition is true or false\n#eval True\n#eval True → False\n#eval False → (1 + 1 = 3)\n#synth Decidable (False → (1 + 1 = 3))\nManually proving Decidable to ensures a computable proof\ninstance : Decidable (p → p ∨ q) := by\n  apply Decidable.isTrue -- explicit use of constructor\n  intro hp\n  left\n  exact hp\n#synth Decidable (p → p ∨ q)\n#eval (p q : Prop) → (p → (p ∨ q))\nDecidable enables partial classical logic\n#check Classical.byContradiction -- we have done this before\nproof by contradiction in intuitionistic logic with decidable hypothesis\nexample [dp : Decidable p] : (¬p → False) → p := by\n  intro hnpn\n  rcases dp with (hnp | hp)\n  · exfalso; exact hnpn hnp\n  · exact hp\n#check Decidable.byContradiction -- above has a name\n\nend",
    "crumbs": [
      "04-logic.lean"
    ]
  },
  {
    "objectID": "01-intro.html",
    "href": "01-intro.html",
    "title": "Introduction to Formal Mathematics with Lean 4",
    "section": "",
    "text": "What is formalization\n\nNatural language vs. formal language\n\nambiguity in natural language\n\nimplicit assumptions\nskipping details: “It’s clear that we have…”\n“viewed as” arguments: \\(V^{**} = V\\), \\((A \\times B) \\times C = A \\times (B \\times C)\\) 1\nabuses of notation: \\(3 \\in \\mathbb Z / 5 \\mathbb Z\\), \\(\\mathbb C \\subseteq \\mathbb C[x]\\)\n\nprecision in formal language\n\ncomputer programs are formal languages\n\n\n1 Knowledgable audience may recognize them as examples of natural isomorphisms in category theory.\n\nMathematical proofs vs. Computer programs2\n\nCurry–Howard correspondence\n\n\nLogic\nProgramming\n\n\n\n\nproposition\ntype\n\n\nproof\nterm\n\n\nproposition is true\ntype has a term\n\n\nproposition is false\ntype doesn’t have a term\n\n\nlogical constant TRUE\nunit type\n\n\nlogical constant FALSE\nempty type\n\n\nimplication \\(\\to\\)\nfunction type\n\n\nconjunction \\(\\land\\)\nproduct type \\(\\prod\\)\n\n\ndisjunction \\(\\lor\\)\nsum type \\(\\sum\\)\n\n\nuniversal quantification \\(\\forall\\)\ndependent product type \\(\\prod\\)\n\n\nexistential quantification \\(\\exists\\)\ndependent sum type \\(\\sum\\)\n\n\n\n\n2 see also Computational Trilogy, with category theory as the third vertex\nSet theory vs. Type theory\n\nMathematicians choose axiomatic set theory (with first-order logic) as the foundation of mathematics.\n\nnaive set theory fits human’s intuition well\n\nType theory is an alternative foundation that is equally expressive, but more suitable for computer formalization.\n\n\n\n\nSet Theory\nType Theory\n\n\n\n\neverything is a set\neverything has a type\n\n\n\\(3 \\in \\mathbb R\\) is a proposition\n\\((3 : \\mathbb R)\\) is a typing judgment\n\n\n\\(\\mathbb Q \\subseteq \\mathbb R\\) is an inclusion\n\\(\\mathbb Q \\to \\mathbb R\\) is a type conversion\n\n\n\n\n\nWhat is Lean 4\n\nA modern functional programming language designed for theorem proving\n\n\n“Lean is based on a version of dependent type theory known as the Calculus of Constructions, with a countable hierarchy of non-cumulative universes and inductive types.” — Theorem Proving in Lean 4\n\n\n\nLean’s dependent type theory\n\nDependent type theory is a powerful extension of type theory where\n\ntypes may depend on terms “given before” them\nfirst-order logic can be implemented in dependent type theory\n\nfunctions, inductive types and quotient types3 are the basic methods to construct new types.\n\n3 Though seemingly redundant, there are reasons for making quotient types as a fundamental constructing method. funext thesis\n\n\nSet Theory\nLean’s dependent type theory\n\n\n\n\n\\(\\forall x \\in \\mathbb R,\\, x^2 \\geq 0\\)\nhas type \\((x : \\mathbb R) \\to (x^2 \\geq 0)\\)\n\n\n\\((n \\in \\mathbb N) \\mapsto (1,0,\\dots,0) \\in \\mathbb R^n\\)\nhas type \\((n : \\mathbb N) \\to \\mathbb R^n\\)\n\n\n\\(\\{ 0,1 \\} = 2\\) is a set equality\nmake no sense\n\n\ncardinality is an equivalence class\nis a quotient type\n\n\nRussell’s paradox\nGirard’s paradox\n\n\n\n\n\nAn example Lean 4 code\n\nFLT\nTendsTo\n\n\n\n\nWhy formalize\n\nThe rise of AI\nAI excels in Python. Why not Lean?\n\nAutomated theorem proving\n\nespecially those “abstract nonsense”\nfull-auto (create a proof without human interaction)\nsemi-auto (suggest tactics)\n\nexact?, Github Copilot, …\n\n\nNatural language to formal language\n\nautomatically transplanting textbooks and papers into Lean\nfull-auto (translate without human interaction)\nbolt-action (search for existing theorems)\n\nLeanSearch, LeanExplore, …\n\nConverse? Already happening!\n\nProposing conjectures\n\non which facts should we care about\n\n\n\n\nRigor matters\n\nIt’s the foundation of mathematics\nImprecise natural language often leads to misunderstandings and glitches\n\nEspecially when proofs get longer and longer\n\nformalization fully confirms the correctness of a theorem\n\nthings that are too “technical” (boring) or simply impossible to verify by oneself\n\ne.g. classification of finite simple groups\ne.g. “technical”\n\n\n“I spent much of 2019 obsessed with the proof of this theorem, almost getting crazy over it. In the end, we were able to get an argument pinned down on paper, but I think nobody else has dared to look at the details of this, and so I still have some small lingering doubts.” — Peter Scholze\n\n\n\n\n\n“Mathematical engineering”\n\nmanipulating tons of theorems and proofs with mature software engineering techniques\nreferencing existing theorems as dependencies\ncollaborative work across the globe\n\n\nThe beauty of the system: you do not have to understand the whole proof of FLT in order to contribute. The blueprint breaks down the proof into many many small lemmas, and if you can formalise a proof of just one of those lemmas then I am eagerly awaiting your pull request. — Kevin Buzzard on the FLT Project\n\n\n\nFormalization as learning\n\nproofs with infinite detail\n\nintuitive textbooks, rigorous formalization\n\nmakes us understand things better\n\nGlobal: How to build natural numbers from scratch?\n\nnatural number game\nA journey to the world of numbers, by Riccardo Brasca\n\nLocal: reducing the cognitive load\n\n(With good organization at the beginning) you can focus on small parts of the proof at a time\n\n\n\n\n\n\nWhy now formalize\n\nFormalization becomes more accessible\nMathematician-friendly languages, interfaces, tools and community emerges:\n\nLean 4 with VSCode extension, modern interactive theorem prover made for mathematicians\nformalization becomes more and more fashionable\nbig names works on formalization:\n\nKevin Buzzard works on formalizing FLT\nPeter Scholze’s work on condensed mathematics has been formalized\nTerrence Tao gave a talk on formalization in IMO 2024 and wrote a Lean 4 companion of his book “Analysis I” recently\n\ncomputer scientists and volunteering mathematicians run Lean 4 community collaboratively\n\n\n\nMathlib 4 is expanding explosively\nBy the time of 2025/09/16, Mathlib 4 has4\n4 Statistics fetched from Mathlib statistics\n\n\nLines of code\nDefinitions\nTheorems\nContributors\n\n\n\n\n1950000\n115438\n232204\n653\n\n\n\n\nundergraduate may contribute: some low-hanging fruits\n\n\n\n\nHow to formalize\n\nThe goal\nThe goal, at the end of this course, is\n\nto get used to think formally\nto migrate from set theory to dependent type theory\nto practice basic skills to translate statements and proofs into Lean 4\nto know how to find existing theorems, how the community works\nto acquire enough common senses to read the bibles (MiL, TPiL, Mathlib 4 Doc, etc.) by yourself for future formalization projects\n(optimistically) to set up a Lean 4 formalization club at BIT!\n\n\n\nHow will we learn\nAs mathematicians, we learn Lean 4 to formalizing mathematics. We learn by practice.\n\nDozens of Lean files packed with well-organized examples and exercises suffice to get you started, suitable for both guided study and self study. Most lectures will be given in this style.\nThis style of teaching is inspired by Kevin Buzzard’s 2024 course on formalising mathematics in the Lean theorem prover and many other courses.\n\n\n\nWhat we won’t cover\nDue to the limited time, my personal inability and the design of this course, we might not be able to cover:\n\na deep discussion into dependent type theory or Lean as a programming language itself\n\nRead TPiL for a Lean 4 tutorial that emphasizes on type theory.\nRead FPiL for a Lean 4 tutorial that focuses more on functional programming.\nRefer to Lean Language Manual for precise specifications.\n\nsystematic exposition of how a particular branch of mathematics is formalized in Mathlib 4\n\nRead MiL for this purpose.\n\nhow to organize a massive formalization project from scratch, i.e. project management\n\nsomewhat subtle, might can only be learned by reading Mathlib codes and practical experience\n\n\n\n\nDisclaimer\n\nFormalization is tedious in its nature, Lean is no exception\nType conversions can be an extra burden (exclusive for type-theory-based systems)\nKnowledge needs to be re-learned before being referenced\nDifferent people may formalize the same thing in different ways\n\n\n\nIf these do not scare you away…\nWelcome aboard. Have fun formalizing mathematics!\n\n\nResources\n\ncourse repository\nonline documentation",
    "crumbs": [
      "Introduction to Formal Mathematics with Lean 4"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "",
    "text": "形式化数学是将数学定义、定理和证明转化为计算机可验证的精确形式的过程。可以认为，数学形式化 = 编写程序，而正确的证明 = 代码通过编译。严谨性是数学研究的基石，形式化数学通过严格的逻辑框架和程序语言确保数学结论的正确性和可复用性，在现代数学体系日渐庞大复杂的背景下具有重要意义。\nLean 4 是一个专为形式化数学设计的编程语言和证明助手，支持数学家将数学定理转化为计算机可验证的代码。它具备高效的编译器和灵活的类型系统，适合构建复杂的数学证明；其数学库 Mathlib 正在飞速扩展，目前已覆盖本科数学大部分内容。Lean 4 已成为目前数学形式化工作的主流选择。\nAI4Math 是将人工智能技术应用于数学研究的跨学科领域。其目标是通过机器学习、大语言模型等方法，简化形式化过程中的繁重代码编写工作，辅助数学家进行数学形式化、定理证明乃至提出猜想。AI4Math 或将在将来大幅提高数学形式化和数学研究的效率。"
  },
  {
    "objectID": "index.html#背景简介",
    "href": "index.html#背景简介",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "",
    "text": "形式化数学是将数学定义、定理和证明转化为计算机可验证的精确形式的过程。可以认为，数学形式化 = 编写程序，而正确的证明 = 代码通过编译。严谨性是数学研究的基石，形式化数学通过严格的逻辑框架和程序语言确保数学结论的正确性和可复用性，在现代数学体系日渐庞大复杂的背景下具有重要意义。\nLean 4 是一个专为形式化数学设计的编程语言和证明助手，支持数学家将数学定理转化为计算机可验证的代码。它具备高效的编译器和灵活的类型系统，适合构建复杂的数学证明；其数学库 Mathlib 正在飞速扩展，目前已覆盖本科数学大部分内容。Lean 4 已成为目前数学形式化工作的主流选择。\nAI4Math 是将人工智能技术应用于数学研究的跨学科领域。其目标是通过机器学习、大语言模型等方法，简化形式化过程中的繁重代码编写工作，辅助数学家进行数学形式化、定理证明乃至提出猜想。AI4Math 或将在将来大幅提高数学形式化和数学研究的效率。"
  },
  {
    "objectID": "index.html#课程信息",
    "href": "index.html#课程信息",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "课程信息",
    "text": "课程信息\n本兴趣课程旨在向数学或计算机相关专业学生普及形式化数学的基本概念和方法，掌握 Lean 4 定理证明的基本技能，并了解 AI4Math 的最新进展，为后续更深入的探索做好引导。课程设计为 2025 秋季学期范洋宇老师《抽象代数》的配套课余活动，欢迎感兴趣的同学参与。\n本课程原则上不要求任何编程或数学背景，但建议具备至少一侧的常识。我们建议有意动手实操的同学携带电脑，并提前配置好网络、Git、VSCode 等相关环境。\n\n\n\n\n\n\n\n\n\n图 1: 课程群\n\n\n\n\n\n时间：1–12 周周三 18:30–20:05，首次课程 9 月 17 日\n地点：文萃楼 F502\n主讲人：钟星宇\n北京理工大学 2022 级强基数学专业本科生\nMathlib 4 Contributor\nICPC Regional Silver Medalist\n2025 BICMR–RUC 代数与形式化暑期学校学员\nBICMR–Ubiquant AI4Math 数据标注团队实习经验"
  },
  {
    "objectID": "index.html#课程大纲供参考",
    "href": "index.html#课程大纲供参考",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "课程大纲（供参考）",
    "text": "课程大纲（供参考）\n\nIntroduction to Formal Mathematics with Lean 4\nHello World\nLogic\nNumbers, Functions and Sets\nDependent Type Theory in Lean 4\nMathematical Analysis: Taking Limits on the Real Numbers\nRandom Lean 4 Tips\nAbstract Algebra: Group, Rings and Fields\nQuotient Types and Universal Properties\nInductive Types and Induction Methods\nClasses and Instances\nCoercions"
  },
  {
    "objectID": "index.html#参考材料",
    "href": "index.html#参考材料",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "参考材料",
    "text": "参考材料\n\nIntroductory:\n\nCAV2024\nTerence Tao at IMO 2024: AI and Mathematics\nLean 的前世今生\nNatural Number Game\nComputational Trilogy - nLab\n\nBibles\n\nMathematics in Lean 4\nTheorem Proving in Lean 4\nLean Language Manual\nType Theory - nLab\nOther bibles\n\nCourses\n\nKevin Buzzard’s 2024 course on formalising mathematics in the Lean theorem prover\nBICMR–RUC 2025 代数与形式化暑期学校课程材料"
  },
  {
    "objectID": "index.html#链接",
    "href": "index.html#链接",
    "title": "形式化数学与 Lean 4 定理证明入门",
    "section": "链接",
    "text": "链接\n\nCourse materials:\n\ncourse repository\nonline documentation\n\nOnline compiler:\n\nLean 4 Web\n\nCommunity\n\nLean Zulip"
  },
  {
    "objectID": "03-logic.html",
    "href": "03-logic.html",
    "title": "03-logic.lean",
    "section": "",
    "text": "import Mathlib",
    "crumbs": [
      "03-logic.lean"
    ]
  },
  {
    "objectID": "03-logic.html#and-and-or",
    "href": "03-logic.html#and-and-or",
    "title": "03-logic.lean",
    "section": "1 And and Or",
    "text": "1 And and Or\nIn Lean’s dependent type theory, ∧ and ∨ serve as the direct product and the direct sum in the universe of Prop.\nEagle-eyed readers may notice that ∧ and ∨ act similarly to Cartesian product and disjoint union in set theory.\nThey are also constructed as inductive types.\nsection\n\nvariable (p q r : Prop)\n\n1.1 And (∧)\n\nIntroducing And\nThe only constructor of And is And.intro, which takes a proof of p and a proof of q to produce a proof of p ∧ q.\nIt is self-evident. Regard this as the universal property of the direct product if you like.\n#check And.intro\n\nexample (hp : p) (hq : q) : p ∧ q := And.intro hp hq\nAnd.intro hp hq can be abbreviated as ⟨hp, hq⟩, called the anonymous constructor.\nexample (hp : p) (hq : q) : p ∧ q := ⟨hp, hq⟩\nintroducing nested And\nexample (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by\n  exact ⟨hp, hq, hr⟩ -- equivalent to `⟨hp, ⟨hq, hr⟩⟩`\nconstructor tactic applies And.intro to split the goal p ∧ q into subgoals p and q. You may also use the anonymous constructor notation ⟨hp, hq⟩ to mean And.intro hp hq.\nuse · to focus on the first goal in your goal list.\nexample (hp : p) (hq : q) : p ∧ q := by\n  constructor\n  · exact hp\n  · exact hq\non_goal tactic can be used to focus on a specific goal.\nexample (hp : p) (hq : q) : p ∧ q := by\n  constructor\n  on_goal 2 =&gt; exact hq\n  exact hp\nall_goals tactic can be used to simultaneously perform tactics on all goals.\nexample (hp : p) : p ∧ p := by\n  constructor\n  all_goals exact hp\nassumption tactic tries to close goals using existing hypotheses in the context. Can be useful when there are many goals.\nexample (hp : p) (hq : q) : p ∧ q := by\n  constructor\n  all_goals assumption\nsplit_ands tactic is like constructor but works for nested Ands.\nexample (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := by\n  split_ands\n  · exact hp\n  · exact hq\n  · exact hr\n[EXR] →–∨ distribution. Universal property of the direct product.\nexample (hrp : r → p) (hrq : r → q) : r → p ∧ q := by\n  intro hr\n  exact ⟨hrp hr, hrq hr⟩\n\n\nEliminating And\nAnd.left and And.right are among the elimination rules of And, which extract the proofs of p and q.\n#check And.left\n#check And.right\nexample (hpq : p ∧ q) : p := hpq.left\nexample (hpqr : p ∧ q ∧ r) : r := hpqr.right.right\nrcases hpq with ⟨hp, hq⟩ is a tactic that breaks down the hypothesis hpq : p ∧ q into hp : p and hq : q. Equivalently you can use have ⟨hp, hq⟩ := hpq.\nexample (hpq : p ∧ q) : p := by\n  rcases hpq with ⟨hp, _⟩\n  exact hp\nimplicit break-down in intro\nexample : p ∧ q → p := by\n  intro ⟨hp, _⟩\n  exact hp\nnested And elimination\nexample (hpqr : p ∧ q ∧ r) : r := by\n  rcases hpqr with ⟨_, _, hr⟩\n  exact hr\n[EXR] And is symmetric\nexample : p ∧ q → q ∧ p := by\n  intro ⟨hp, hq⟩\n  exact ⟨hq, hp⟩\n#check And.comm -- above has a name\n[EXR] →–∨ distribution, in another direction.\nexample (hrpq : r → p ∧ q) : (r → p) ∧ (r → q) := by\n  constructor\n  · intro hr\n    exact (hrpq hr).left\n  · intro hr\n    exact (hrpq hr).right\n\n\nCurrification\nThe actual universal elimination rule of And is the so-called decurrification: From (p → q → r) we may deduce (p ∧ q → r). This is actually a logical equivalence.\nIntuitively, requiring both p and q to deduce r is nothing but requiring p to deduce that q is sufficient to deduce r.\n[IGNORE] Decurrification is also self-evidently true in Lean’s dependent type theory.\nCurrification is heavily used in functional programming for its convenience, Lean is no exception.\nYou are no stranger to decurrification even if you are not a functional programmer: The universal property of the tensor product of modules says exactly the same. \\[\n\\operatorname{Hom}(M \\otimes N, P) \\cong \\operatorname{Hom}(M, \\operatorname{Hom}(N, P))\n\\]\n[EXR] currification\nexample (h : p ∧ q → r) : (p → q → r) := by\n  intro hp hq\n  exact h ⟨hp, hq⟩\n[EXR] decurrification\nexample (h : p → q → r) : (p ∧ q → r) := by\n  intro hpq\n  exact h hpq.left hpq.right\n\nexample (h : p → q → r) : (p ∧ q → r) := by\n  intro ⟨hp, hq⟩ -- `intro` is smart enough to destructure `And`\n  exact h hp hq\n\nexample (h : p → q → r) : (p ∧ q → r) := by\n  intro ⟨hp, hq⟩\n  apply h -- `apply` is smart enough to auto-decurrify and generate two subgoals\n  · exact hp\n  · exact hq\n[IGNORE] decurrification actually originates from And.rec, which is self-evident\n#check And.rec\ntheorem decurrify (h : p → q → r) : (p ∧ q → r) := And.rec h\nAnd.left is actually a consequence of decurrification\nexample : p ∧ q → p := by\n  apply decurrify\n  intro hp _\n  exact hp\n\n\n\n1.2 Iff (↔︎), first visit\nIt’s high time to introduce Iff here for the first time.\nIff (↔︎) contains two side of implications: Iff.mp and Iff.mpr.\nThough it is defined as a distinct inductive type, Iff may be seen as a bundled version of (p → q) ∧ (q → p). you may, somehow, even use it like a (p → q) ∧ (q → p). The only major difference is the name of the two components.\n#check Iff.intro\n#check Iff.mp\n#check Iff.mpr\n\nexample : (p ↔ q) ↔ (p → q) ∧ (q → p) := by\n  constructor\n  · intro h\n    exact ⟨h.mp, h.mpr⟩\n  · intro ⟨hpq, hqp⟩\n    exact ⟨hpq, hqp⟩\n\n\n1.3 Or (∨)\n\nIntroducing Or\nOr has two constructors, Or.inl and Or.inr. Either a proof of p or a proof of q produces a proof of p ∨ q.\n#check Or.inl\n#check Or.inr\n\nexample (hp : p) : p ∨ q := Or.inl hp\nleft (resp. right) tactic reduce Or goals to p (resp. q)\nexample (hq : q) : p ∨ q := by\n  right\n  exact hq\n\n\nEliminating Or\nTo prove r from p ∨ q, it suffices to prove both p → r and q → r. This is the elimination rule of Or, or the universal property of the direct sum.\n#check Or.elim\n#check Or.rec -- [IGNORE]\n\nexample (hpr : p → r) (hqr : q → r) : (p ∨ q → r) := fun hpq ↦ (Or.elim hpq hpr hqr)\nexample (hpr : p → r) (hqr : q → r) : (p ∨ q → r) := (Or.elim · hpr hqr) -- note the use of `·`\nexample (hpr : p → r) (hqr : q → r) (hpq : p ∨ q) : r := by\n  apply Or.elim hpq\n  · exact hpr\n  · exact hqr\nmatch-style syntax is designed to make use of Or.elim to destructure Or to cases. [IGNORE] You may just skim through this syntax for now.\nexample (hpr : p → r) (hqr : q → r) : (p ∨ q → r) := fun\n  | Or.inl hp =&gt; hpr hp\n  | Or.inr hq =&gt; hqr hq\nexample (hpr : p → r) (hqr : q → r) (hpq : p ∨ q) : r :=\n  match hpq with\n  | Or.inl hp =&gt; hpr hp\n  | Or.inr hq =&gt; hqr hq\nexample (hpr : p → r) (hqr : q → r) (hpq : p ∨ q) : r := by\n  match hpq with\n  | Or.inl hp =&gt; exact hpr hp\n  | Or.inr hq =&gt; exact hqr hq\nexample (hpr : p → r) (hqr : q → r) (hpq : p ∨ q) : r := by\n  cases hpq with\n  | inl hp =&gt; exact hpr hp\n  | inr hq =&gt; exact hqr hq\nrcases may also serve as a tactic version of match, which is much more convenient.\nexample (hpr : p → r) (hqr : q → r) (hpq : p ∨ q) : r := by\n  rcases hpq with (hp | hq) -- `rcases` can also destructure `Or`\n  · exact hpr hp\n  · exact hqr hq\nexample (hpr : p → r) (hqr : q → r) : p ∨ q → r := by\n  rintro (hp | hq) -- `rintro` is a combination of `intro` and `rcases`\n  · exact hpr hp\n  · exact hqr hq\n[EXR] distributive laws\nexample : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by sorry\nexample : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := by sorry\n\nend",
    "crumbs": [
      "03-logic.lean"
    ]
  },
  {
    "objectID": "03-logic.html#forall-and-exists",
    "href": "03-logic.html#forall-and-exists",
    "title": "03-logic.lean",
    "section": "2 Forall and Exists",
    "text": "2 Forall and Exists\n\n2.1 Forall (∀)\nAs you may have already noticed, ∀ is just an alternative way of writing →. Say p is a predicate on a type X, i.e. of type X → Prop, then ∀ x : X, p x is exactly the same as (x : X) → p x.\nThough → is primitive in Lean’s dependent type theory, we may still (perhaps awkwardly) state the introduction and elimination rules of ∀:\n\nIntroduction: fun (x : X) ↦ (h x : p x) produces a proof of ∀ x : X, p x.\nElimination: Given a proof h of ∀ x : X, p x, we can obtain a proof of p a for any specific a : X. It is exactly h a.\n\nsection\n\nvariable {X : Type} (p q : X → Prop) (r s : Prop) (a b : X)\n\n#check ∀ x : X, p x\n#check ∀ x, p x -- Lean is smart enough to infer the type of `x`\n\nexample : (∀ x : X, p x) → p a := by\n  intro h\n  exact h a\n[IGNORE] Writing ∀ emphasizes that the arrow → is of dependent type, and the domain X is a type, not a proposition. But they are just purely psychological, as the following examples show.\nexample : (hrs : r → s) → (∀ _ : r, s) := by\n  intro hrs\n  exact hrs\n\n\n2.2 Exists (∃)\n∃ is a bit more complicated.\nSlogan: ∀ is a dependent →, ∃ is a dependent × (or ∧ in Prop universe)\n#check ∃ x : X, p x\n#check ∃ x, p x -- Lean is smart enough to infer the type of `x`\n\nIntroducting Exists\n∃ x : X, p x means that we have the following data:\n\nan element a : X;\na proof h : p a.\n\nSo a pair (a, h) would suffice to construct a proof of ∃ x : X, p x.\nThis is the defining introduction rule of Exists as an inductive type.\n#check Exists.intro\nexample (a : X) (h : p a) : ∃ x, p x := Exists.intro a h\nAs like And, you may use the anonymous constructor notation ⟨a, h⟩ to mean Exists.intro a h.\nexample (a : X) (h : p a) : ∃ x, p x := ⟨a, h⟩\nIn tactic mode, use a make use of Exists.intro a to reduce the goal ∃ x : X, p x to p a.\nexample (a : X) (h : p a) : ∃ x, p x := by use a\n\n-- [EXR]\nexample (x y z : ℕ) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=\n  ⟨y, ⟨hxy, hyz⟩⟩\nNote that in the defining pair (a, h), h is a proof of p a, whose type depends on a. Thus psychologically, you may view ∃ x : X, p x as a dependent pair type (x : X) × (p x).\nHave writing Exists as a dependent pair type reminded you of the currification process?\n\n\nEliminating Exists\nTo construct the implication (∃ x : X, p x) → q, it suffices to have a proof of (∀ x : X, p x → q), i.e. (x : X) → p x → q. Exists.elim does exactly above.\n#check Exists.elim\n\nexample : (∀ x, p x → r) → ((∃ x, p x) → r) := by\n  intro hf he\n  exact Exists.elim he hf\nIn tactic mode, rcases h with ⟨a, ha⟩ make use of this elimination rule to break down a hypothesis h : ∃ x : X, p x into a witness a : X and a proof ha : p a.\nexample : (∀ x, p x → r) → ((∃ x, p x) → r) := by\n  intro hf he\n  rcases he with ⟨a, hpa⟩\n  exact hf a hpa\n\nexample : (∀ x, p x → r) → ((∃ x, p x) → r) := by\n  intro h ⟨a, hpa⟩ -- you may also `rcases` explicitly\n  exact h a hpa\n[EXR] reverse direction is also true\nexample :  ((∃ x, p x) → r) → (∀ x, p x → r) := by\n  intro h a hpa\n  apply h\n  use a\n\n-- [EXR]\nexample : (∃ x, r ∧ p x) → r ∧ (∃ x, r ∧ p x) := by\n  intro ⟨a, ⟨hr, hpa⟩⟩\n  exact ⟨hr, ⟨a, ⟨hr, hpa⟩⟩⟩\n\n-- [EXR]\nexample : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) := by\n  constructor\n  · rintro ⟨a, (hpa | hqa)⟩\n    · left; use a\n    · right; use a\n  · rintro (⟨a, hpa⟩ | ⟨a, hqa⟩)\n    · use a; left; exact hpa\n    · use a; right; exact hqa\n\nend\n\n\n[IGNORE] A cosmological remark\nThe pair (a, h) actually do not have type (x : X) × (p x). The latter notation is actually for the dependent pair type (or Sigma type), which lives in Type* universe.\nBut Exists should live in Prop, and in Prop universe we admit proof-irrelevance, i.e. we do not save data. So Exists forget the exact witness a once it is proved.\nThis “forgetfulness” is revealed by the fact that there is no elimination rule Exists.fst to extract the witness a from a proof of ∃ x : X, p x, as long as X lives in the Type* universe. (Note that Exists.elim can only produce propositions in Prop)\nBut if X lives in Prop universe, then we do have Exists.fst:\nsection\n\n#check Exists.fst\nWait, wait, we never worked with X : Prop before. Say p : r → Prop and r s : Prop, what does ∃ hr : r, p hr mean? It means that r and p hr are both true? [TODO] I don’t know how to explain this properly so far.\nvariable (r : Prop) (p : r → Prop)\n#check ∃ hr : r, p hr\n\n-- Prove `Exists.fst` and `Exists.snd` by `Exists.elim`\nexample (he : ∃ hr : r, p hr) : r ∧ p he.fst := by\n  apply Exists.elim he\n  intro hr hpr\n  exact ⟨hr, hpr⟩\n\nend",
    "crumbs": [
      "03-logic.lean"
    ]
  },
  {
    "objectID": "03-logic.html#ignore-a-cosmological-remark-continued",
    "href": "03-logic.html#ignore-a-cosmological-remark-continued",
    "title": "03-logic.lean",
    "section": "3 [IGNORE] A cosmological remark, continued",
    "text": "3 [IGNORE] A cosmological remark, continued\nSame construction, different universes. Other examples are also shown below.\n#print And -- `×` in `Prop`\n#print Prod -- `×` in `Type*`\n\n-- Forall `∀`: dependent `∏` in `Prop`\n-- dependent function type: dependent `∏` in `Type*`\n\n#print Or -- `⊕` in `Prop`\n#print Sum -- `⊕` in `Type*`\n\n#print Exists -- dependent `∑` in `Prop`\n#print Sigma -- dependent `Σ` in `Type*`\n\n#print Nonempty -- a proof of non-emptiness living in `Prop`\n#print Inhabited -- an designated element living in `Sort*`",
    "crumbs": [
      "03-logic.lean"
    ]
  },
  {
    "objectID": "03-logic.html#remainder",
    "href": "03-logic.html#remainder",
    "title": "03-logic.lean",
    "section": "4 Remainder",
    "text": "4 Remainder\nIff (↔︎), second visit, bundled and unbundled version\nwe do it with Eq? Eq is hard. Maybe a second visit when touching inductive types.",
    "crumbs": [
      "03-logic.lean"
    ]
  },
  {
    "objectID": "02-logic.html",
    "href": "02-logic.html",
    "title": "02-logic.lean",
    "section": "",
    "text": "import Mathlib\nYou may skip the materials tagged with [IGNORE] for the first runthrough. Most of them are here to illustrate the nature of inductive types, which may be too advanced for beginners.\nMaterials tagged with [EXR] are recommended for you to try before looking at the solution.",
    "crumbs": [
      "02-logic.lean"
    ]
  },
  {
    "objectID": "02-logic.html#and",
    "href": "02-logic.html#and",
    "title": "02-logic.lean",
    "section": "1 : and :=",
    "text": "1 : and :=\n3 : ℕ means that 3 is a term of type ℕ.\nBy the Curry–Howard correspondence, hp : p means that hp is a proof of the proposition p.\n#check 3\n#check ℕ\n\n#check ∀ x : ℝ, 0 ≤ x ^ 2\n#check sq_nonneg\n#check (sq_nonneg : ∀ x : ℝ, 0 ≤ x ^ 2)\n:= is used to define terms.\ndef myThree : ℕ := 3\n\n#check myThree\ntheorem is just a definition in the Prop universe By the Curry–Howard correspondence, for theorem, behind :, the theorem statement follows; behind :=, a proof should be given.\ntheorem thm_sq_nonneg : ∀ x : ℝ, 0 ≤ x ^ 2 := sq_nonneg\n\n-- `example` is just an anonymous theorem\nexample : ∀ x : ℝ, 0 ≤ x ^ 2 := thm_sq_nonneg",
    "crumbs": [
      "02-logic.lean"
    ]
  },
  {
    "objectID": "02-logic.html#implication",
    "href": "02-logic.html#implication",
    "title": "02-logic.lean",
    "section": "1 Implication →",
    "text": "1 Implication →\nImplication → is the most fundamental way of constructing new types in Lean’s dependent type theory. It’s one of the first-class citizens in Lean.\nIn the universe of Prop, for propositions p and q, the implication p → q means “if p then q”.\nsection\n\nvariable (p q r : Prop) -- this introduces global variables within this section\n\n#check p\n#check q\n#check p → q\n→ is right-associative. In general, hover the mouse over the operators to see how they associate. so p → q → r means p → (q → r). You may notice that this is logically equivalent to p ∧ q → r. This relationship is known as currification. We shall discuss this later.\nmodus ponens\ntheorem mp : p → (p → q) → q := by sorry -- `sorry` is a placeholder for unfinished proofs\nBy the Curry–Howard correspondence, p → q is also understood as a function that takes a proof of p and produces a proof of q.\nWe introduce an important syntax to define functions / theorems: When we define a theorem theorem name (h1 : p1) ... (hn : pn) : q := ..., we are actually defining a function name of type (h1 : p1) → ... → (hn : pn) → q. Programmingly, h1, …, hn are the parameters of the function and q is the return type.\nThe significance of this syntax, compared to theorem name : p1 → ... → pn → q := ..., is that now h1, …, hn, proofs of p1, …, pn, are now introduced as hypotheses into the context, available for you along the way to prove q.\nthis proves a theorem of type p → p\nexample (hp : p) : p := hp\nmodus ponens, with a proof\nexample (hp : p) (hpq : p → q) : q := hpq hp\nA function can also be defined inline, using fun (lambda syntax): fun (h1 : p1) ... (hn : pn) ↦ (hq : q) defines a function of type (h1 : p1) → ... → (hn : pn) → q\nSome of the type specifications may be omitted, as Lean can infer them.\nexample : p → p := fun (hp : p) ↦ (hp : p)\nexample : p → p := fun (hp : p) ↦ hp\nexample : p → (p → q) → q := fun (hp : p) (hpq : p → q) ↦ hpq hp\nexample : p → (p → q) → q := fun hp hpq ↦ hpq hp",
    "crumbs": [
      "02-logic.lean"
    ]
  },
  {
    "objectID": "02-logic.html#tactic-mode",
    "href": "02-logic.html#tactic-mode",
    "title": "02-logic.lean",
    "section": "2 Tactic Mode",
    "text": "2 Tactic Mode\nConstruct proofs using explicit terms is called term-style proof. This can be tedious for complicated proofs.\nFortunately, Lean provides the tactic mode to help us construct proofs interactively.\nby activates the tactic mode.\nThe tactic mode captures the way mathematicians actually think: There is a goal q to prove, and we have several hypotheses h1 : p1, …, hn : pn in the context to use. We apply tactics to change the goal and the context until the goal is solved. This produces a proof of p1 → ... → pn → q.\nexample (hp : p) : p := by exact hp\ntactic: exact If the goal is p and we have hp : p, then exact hp solves the goal.\nexact? may help to close some trivial goals\nexample (hp : p) (hpq : p → q) : q := by exact?\ntactic: intro Sometimes a hypothesis is hidden in the goal in the form of an implication. If the goal is p → q, then intro hp changes the goal to q and adds the hypothesis hp : p into the context.\nmodus ponens, with a hidden hypothesis\nexample (hp : p) : (p → q) → q := by\n  intro hpq\n  exact hpq hp\n\nexample (hq : q) : p → q := by\n  intro _  -- use `_` as a placeholder if the introduced hypothesis is not needed\n  exact hq\nmodus ponens, with two hidden hypothesis\nexample : p → (p → q) → q := by\n  intro hp hpq -- you can `intro` multiple hypotheses at once\n  exact hpq hp\n[EXR] transitivity of →\nexample : (p → q) → (q → r) → (p → r) := by\n  intro hpq hqr hp\n  exact hqr (hpq hp)\ntactic: apply If q is the goal and we have hpq : p → q, then apply hpq changes the goal to p.\nmodus ponens\nexample (hp : p) (hpq : p → q) : q := by\n  apply hpq\n  exact hp\n[EXR] transitivity of →\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  apply hqr\n  apply hpq\n  exact hp\nAbove tactics are minimal and sufficient for simple proofs.\nWhen proofs went more complicated, you may want more tactics that suit your needs.\nRemember your favorite tactics and use them accordingly.\ntactic: specialize If we have hpq : p → q and hp : p, then specialize hpq hp reassigns hpq to hpq hp, a proof of q.\nexample (hp : p) (hpq : p → q) : q := by\n  specialize hpq hp\n  exact hpq\n\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  specialize hpq hp\n  specialize hqr hpq\n  exact hqr\ntactic: have have helps you to state and prove a lemma in the middle of a proof. have h : p := hp adds the hypothesis h : p into the context, where hp is a proof of p that you provide.\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  have hq : q := hpq hp\n  have hr : r := by -- combine with `by` is also possible\n    apply hqr\n    exact hq\n  exact hr\ntactic: suffices Say our goal is q, suffices hp : p from hq changes the goal to p, as long as you can provide a proof hq of q from a proof hp of p. You may also switch to the tactic mode by suffices hp : p by ...\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  suffices hq : q from hqr hq\n  exact hpq hp\n\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  suffices hq : q by\n    apply hqr\n    exact hq\n  exact hpq hp\nshow (it is not a tactic!) Sometimes you want to clarify what exactly you are giving a proof for. show p from h make sure that h is interpreted as a proof of p. show p by ... switches to the tactic mode to construct a proof of p.\nexample (hpq : p → q) (hqr : q → r) : p → r := by\n  intro hp\n  exact hqr (show q by apply hpq; exact hp)\n\nend",
    "crumbs": [
      "02-logic.lean"
    ]
  },
  {
    "objectID": "01-intro-code.html",
    "href": "01-intro-code.html",
    "title": "01-intro.lean",
    "section": "",
    "text": "import Mathlib\nFermat’s Last Theorem: if n &gt; 2, then there are no positive integer solutions to a^n + b^n = c^n.\ntheorem FLT (n : ℕ) (hn : n &gt; 2) (a b c : ℕ) : a ≠ 0 → b ≠ 0 → c ≠ 0 → a^n + b^n ≠ c^n := by\n  sorry\n\ndef TendsTo (a : ℕ → ℝ) (t : ℝ) : Prop :=\n  ∀ ε &gt; 0, ∃ n₀ : ℕ, ∀ n, n₀ ≤ n → |a n - t| &lt; ε\n\nexample : TendsTo (fun _ ↦ 998244353) 998244353 := by\n  unfold TendsTo\n  intro ε hε\n  use 19260817\n  intro n hn\n  simp [hε]\n\ntheorem tendsTo_add {a b : ℕ → ℝ} {A : ℝ} {B : ℝ} (ha : TendsTo a A) (hb : TendsTo b B) :\n    TendsTo (fun n =&gt; a n + b n) (A + B) := by\n  sorry\n\ntheorem tendsTo_sandwich {a b c : ℕ → ℝ} {L : ℝ} (ha : TendsTo a L) (hc : TendsTo c L)\n    (hab : ∀ n, a n ≤ b n) (hbc : ∀ n, b n ≤ c n) : TendsTo b L := by\n  sorry",
    "crumbs": [
      "01-intro.lean"
    ]
  }
]