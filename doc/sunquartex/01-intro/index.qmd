---
title: Introduction to the Lean 4 Theorem Prover
subtitle: For newcomers to formalization methods
date: 2025/09/15
author: Xingyu Zhong
institute: Beijing Institue of Technology
shortinstitute: BIT
lang: en

format:
  beamer:
    toc: true 
---

# What is formalization

### Natural language vs. formal language

- ambiguity in natural language

  - implicit assumptions
  - skipping details: "It's clear that we have..."
  - "viewed as" arguments: $V^* = V$, $(A \times B) \times C = A \times (B \times C)$
  - abuses of notation: $3 \in \mathbb Z / 5 \mathbb Z$

- precision in formal language

  - computer programs are formal languages

### Curry--Howard correspondence

:::::{#tbl-curry-howard}

:::{.list-table aligns="c,c" width="1,1"}

* - Logic side
  - Programming side
* - proposition
  - type
* - proof
  - term
* - proposition is true
  - type has a term
* - proposition is false
  - type doesn't have a term
* - logical constant `TRUE`
  - unit type
* - logical constant `FALSE`
  - empty type
* - implication $\to$
  - function type
* - conjunction $\land$
  - product type $\prod$
* - disjunction $\lor$
  - sum type $\sum$
* - universal quantification $\forall$
  - dependent product type $\prod$
* - existential quantification $\exists$
  - dependent sum type $\sum$
:::

Mathematical proofs are in one-to-one correspondence with computer programs
:::::

### What is Lean 4

- A modern programming language designed for theorem proving

### A typical Lean theorem

- FLT

# Why formalize

### The rise of AI

AI excels in Python. Why not Lean?

- Automated theorem proving

  - especially those "abstract nonsense"

- Natural language to formal language

  - automatically transplanting textbooks and papers into Lean
  - Converse? Already happening!

- Proposing conjectures

  - On which facts should we care about

### Rigor matters

- It's the foundation of mathematics

- Inprecise natural language often leads to misunderstandings and glitches

  - Especially when proofs get longer and longer

- formalization fully confirms the correctness of a theorem
  
  - things that are too "technical" (boring) or simply impossible to verify by oneself
  
    - e.g. classification of finite simple groups

    - e.g. "technical"

    > "I spent much of 2019 obsessed with the proof of this theorem, almost getting crazy over it. In the end, we were able to get an argument pinned down on paper, but I think nobody else has dared to look at the details of this, and so I still have some small lingering doubts." --- [Peter Scholze](https://www.nature.com/articles/d41586-021-01627-2)

###

- manipulating tons of theorems and proofs with mature software engineering techniques

- referencing existing theorems as dependencies

- collaborative work across the globe

> The beauty of the system: you do not have to understand the whole proof of FLT in order to contribute. The blueprint breaks down the proof into many many small lemmas, and if you can formalise a proof of just one of those lemmas then I am eagerly awaiting your pull request. --- [Kevin Buzzard on the FLT Project](https://leanprover-community.github.io/blog/posts/FLT-announcement/)

###

- Formalization as learning

- proofs with infinite detail

  - intuitive textbooks, rigorous formalization

- makes us understand things better

  - Global: How to build natural numbers from scratch?

    - [natural number game](https://adam.math.hhu.de/#/g/leanprover-community/nng4)
    - [A journey to the world of numbers, by Riccardo Brasca](https://github.com/riccardobrasca/Numbers)
  
  - Local: reducing the cognitive load

    - (With good organization at the beginning) you can focus on small parts of the proof at a time

# Why now formalize

### Mathematician-friendly community

- mathematician-friendly languages, interfaces, tools and community emerges

### Mathlib 4 is expanding explosively

- undergraduate may contribute: some low fruits

# How to formalize

### What you will learn

### A typical Lean file

- mathematical analysis

### Drawbacks

- Formalization is tedious in its nature, Lean 4 is no exception

- Type conversions can be an extra burden (exclusive for type-theory-based systems)

- Knowledge needs to be re-learned before being referenced

### References

blah